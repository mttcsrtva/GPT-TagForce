<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Force-Directed Graph</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }
        #graph-container {
            width: 100%;
            height: 800px;
            border: 2px solid #333;
            margin-bottom: 40px;
            overflow: hidden;
            position: relative;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node {
            cursor: pointer;
        }
        .node text {
            pointer-events: none;
            font-size: 12px;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .hidden {
            opacity: 0.2;
        }
        .tag-node rect {
            fill: #fff;
            stroke: #333;
            rx: 5;
            ry: 5;
        }
        .tag-node text {
            fill: #333;
            font-size: 12px;
        }
        #tooltip {
            position: absolute;
            text-align: center;
            padding: 10px;
            font-size: 12px;
            background: #333;
            color: #fff;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
        #modal {
            display: none;
            position: fixed;
            z-index: 2000;
            padding-top: 50px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(51, 51, 51, 0.95);
        }
        #modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            max-width: 800px;
            max-height: 80vh;
            position: relative;
            border: 2px solid #333;
            overflow-y: auto;
        }
        #close-button {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 2rem;
            color: #333;
            cursor: pointer;
        }
        #modal-body img {
            max-width: 100%;
            height: auto;
            margin-bottom: 20px;
        }
        #modal-body h2 {
            margin-top: 0;
        }
        #search-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }
        #search-input {
            width: 200px;
            padding: 5px;
            font-size: 14px;
            border: 2px solid #333;
            border-radius: 4px;
            background-color: white;
        }
        #search-input::placeholder {
            color: #999;
            opacity: 0.7;
        }
        #autocomplete-list {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            background-color: white;
        }
        .autocomplete-items {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #d4d4d4;
        }
        .autocomplete-items:hover {
            background-color: #e9e9e9;
        }
        .modal-tag {
            display: inline-block;
            background-color: #f1f1f1;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 2px;
            cursor: pointer;
        }
        .modal-tag:hover {
            background-color: #e9e9e9;
        }
        #reset-button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 14px;
            background-color: #f1f1f1;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            cursor: pointer;
        }
        #reset-button:hover {
            background-color: #e9e9e9;
        }
    </style>
</head>
<body>
    <div id="graph-container">
        <div id="search-container">
            <input type="text" id="search-input" placeholder="Search tag">
            <button id="reset-button">Reset</button>
            <div id="autocomplete-list"></div>
        </div>
    </div>
    <div id="tooltip" class="hidden"></div>
    <div id="modal">
        <div id="modal-content">
            <span id="close-button">&times;</span>
            <div id="modal-body"></div>
        </div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const fullGraph = <!--GRAPH_DATA_PLACEHOLDER-->;
        let currentGraph = JSON.parse(JSON.stringify(fullGraph));

        const width = window.innerWidth;
        const height = 800;

        const svg = d3.select("#graph-container").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom()
                .scaleExtent([0.1, 10])
                .on("zoom", function (event) {
                    g.attr("transform", event.transform);
                }));

        const g = svg.append("g");

        let simulation, link, node;

        function renderGraph(graphData) {
            // Clear existing graph
            g.selectAll("*").remove();

            // Recreate simulation with new data
            simulation = d3.forceSimulation(graphData.nodes)
                .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(150))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));

            // Recreate links
            link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(graphData.links)
                .enter().append("line")
                .attr("class", "link");

            // Recreate nodes
            node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(graphData.nodes)
                .enter().append("g")
                .attr("class", d => d.type === 'tag' ? 'node tag-node' : 'node')
                .on("mouseover", mouseOver)
                .on("mouseout", mouseOut)
                .on("click", nodeClicked)
                .call(drag(simulation));

            // Add images or tag boxes to nodes
            node.each(function(d) {
                if (d.type === 'image') {
                    d3.select(this).append("image")
                        .attr("xlink:href", d.image_data)
                        .attr("x", -50)
                        .attr("y", -50)
                        .attr("width", 100)
                        .attr("height", 100);
                } else if (d.type === 'tag') {
                    const group = d3.select(this);
                    const text = group.append("text")
                        .text(d.name)
                        .attr("dy", 4);
                    const bbox = text.node().getBBox();
                    group.insert("rect", "text")
                        .attr("x", bbox.x - 5)
                        .attr("y", bbox.y - 2)
                        .attr("width", bbox.width + 10)
                        .attr("height", bbox.height + 4);
                }
            });

            // Update simulation
            simulation.nodes(graphData.nodes).on("tick", ticked);
            simulation.force("link").links(graphData.links);
        }

        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        }

        function filterGraph(tagName) {
            const connectedNodes = new Set();
            const connectedLinks = [];

            // Level 1: Find the selected tag node
            const tagNode = fullGraph.nodes.find(node => node.type === 'tag' && node.name === tagName);
            if (!tagNode) {
                console.error('Tag not found:', tagName);
                return;
            }
            connectedNodes.add(tagNode.id);

            // Find images connected to the tag
            const connectedImages = new Set();
            fullGraph.links.forEach(link => {
                const sourceId = getNodeId(link.source);
                const targetId = getNodeId(link.target);

                if (sourceId === tagNode.id) {
                    const targetNode = getNodeById(targetId);
                    if (targetNode.type === 'image') {
                        connectedNodes.add(targetId);
                        connectedLinks.push({
                            source: tagNode,
                            target: targetNode
                        });
                        connectedImages.add(targetId);
                    }
                } else if (targetId === tagNode.id) {
                    const sourceNode = getNodeById(sourceId);
                    if (sourceNode.type === 'image') {
                        connectedNodes.add(sourceId);
                        connectedLinks.push({
                            source: sourceNode,
                            target: tagNode
                        });
                        connectedImages.add(sourceId);
                    }
                }
            });

            // Level 2: Find tags connected to the images from Level 1 (excluding the original tag)
            connectedImages.forEach(imageId => {
                fullGraph.links.forEach(link => {
                    const sourceId = getNodeId(link.source);
                    const targetId = getNodeId(link.target);

                    if (sourceId === imageId) {
                        const targetNode = getNodeById(targetId);
                        if (targetNode.type === 'tag' && targetNode.id !== tagNode.id) {
                            connectedNodes.add(targetId);
                            connectedLinks.push({
                                source: getNodeById(imageId),
                                target: targetNode
                            });
                        }
                    } else if (targetId === imageId) {
                        const sourceNode = getNodeById(sourceId);
                        if (sourceNode.type === 'tag' && sourceNode.id !== tagNode.id) {
                            connectedNodes.add(sourceId);
                            connectedLinks.push({
                                source: sourceNode,
                                target: getNodeById(imageId)
                            });
                        }
                    }
                });
            });

            // Create filtered graph data
            currentGraph = {
                nodes: fullGraph.nodes.filter(n => connectedNodes.has(n.id)),
                links: connectedLinks
            };

            // Render the new filtered graph
            renderGraph(currentGraph);
        }

        function getNodeId(node) {
            return typeof node === 'object' ? node.id : node;
        }

        function getNodeById(id) {
            return fullGraph.nodes.find(node => node.id === id);
        }

        function resetGraph() {
            currentGraph = JSON.parse(JSON.stringify(fullGraph));
            renderGraph(currentGraph);
        }

        function mouseOver(event, d) {
            const connectedNodes = new Set([d.id]);
            currentGraph.links.forEach(link => {
                const sourceId = getNodeId(link.source);
                const targetId = getNodeId(link.target);

                if (sourceId === d.id) connectedNodes.add(targetId);
                if (targetId === d.id) connectedNodes.add(sourceId);
            });
            node.classed('hidden', n => !connectedNodes.has(n.id));
            link.classed('hidden', l => {
                const sourceId = getNodeId(l.source);
                const targetId = getNodeId(l.target);
                return !(connectedNodes.has(sourceId) && connectedNodes.has(targetId));
            });

            d3.select("#tooltip")
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY + 10) + 'px')
                .html(d.type === 'image' ? d.filename : d.name)
                .classed('hidden', false);
        }

        function mouseOut(event, d) {
            node.classed('hidden', false);
            link.classed('hidden', false);
            d3.select("#tooltip").classed('hidden', true);
        }

        function nodeClicked(event, d) {
            if (d.type === 'tag') {
                resetGraph();  // First reset to full graph
                filterGraph(d.name);  // Then filter based on the clicked tag
            } else if (d.type === 'image') {
                showModal(d);
            }
        }

        function showModal(d) {
            const modal = document.getElementById("modal");
            const modalContent = document.getElementById("modal-body");
            const tagHtml = d.tags.map(tag => `<span class="modal-tag" onclick="filterGraph('${tag}')">${tag}</span>`).join(' ');
            modalContent.innerHTML = `
                <h2>${d.filename}</h2>
                <p><strong>Description:</strong> ${d.description}</p>
                <p><strong>Tags:</strong> ${tagHtml}</p>
                <img src="${d.image_data}" alt="${d.filename}">
            `;
            modal.style.display = "block";
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        const searchInput = document.getElementById('search-input');
        const autocompleteList = document.getElementById('autocomplete-list');

        searchInput.addEventListener('input', function() {
            const inputVal = this.value.toLowerCase();
            autocompleteList.innerHTML = '';
            if (!inputVal) {
                resetGraph();
                return;
            }

            const matchingTags = fullGraph.nodes
                .filter(node => node.type === 'tag' && node.name.toLowerCase().startsWith(inputVal))
                .map(node => node.name);

            matchingTags.forEach(tag => {
                const div = document.createElement('div');
                div.innerHTML = tag;
                div.addEventListener('click', function() {
                    searchInput.value = this.innerHTML;
                    filterGraph(this.innerHTML);
                    autocompleteList.innerHTML = '';
                });
                div.className = 'autocomplete-items';
                autocompleteList.appendChild(div);
            });
        });

        document.addEventListener('click', function(e) {
            if (e.target !== searchInput && e.target !== autocompleteList) {
                autocompleteList.innerHTML = '';
            }
        });

        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const inputVal = this.value.toLowerCase();
                const matchingTag = fullGraph.nodes.find(node => node.type === 'tag' && node.name.toLowerCase() === inputVal);
                if (matchingTag) {
                    filterGraph(matchingTag.name);
                }
                autocompleteList.innerHTML = '';
            }
        });

        document.getElementById("close-button").addEventListener("click", () => {
            document.getElementById("modal").style.display = "none";
        });

        document.getElementById("reset-button").addEventListener("click", resetGraph);

        window.addEventListener("click", (event) => {
            const modal = document.getElementById("modal");
            if (event.target == modal) {
                modal.style.display = "none";
            }
        });

        // Initial render
        renderGraph(currentGraph);
        window.filterGraph = filterGraph;
    </script>
</body>
</html>
